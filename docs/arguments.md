# Анализ стратегических подходов к развитию архитектуры данных

Этот документ фиксирует анализ двух вариантов развития архитектуры хранения данных для принятия взвешенного решения.

## Вариант 1: Поэтапная миграция (Firestore -> Cloud SQL)

Этот подход предполагает два шага:
1.  **Сейчас:** Быстрый переход на `Firestore` для товаров и `Firebase Storage` для изображений.
2.  **В будущем:** Повторная миграция с `Firestore` на `Cloud SQL`, когда проект вырастет.

### Плюсы

*   **Максимальная скорость сейчас:** Переход на `Firestore + Firebase Storage` — самый быстрый способ решить текущую проблему. Мы остаемся в уже знакомой экосистеме Firebase.
*   **Низкие начальные затраты:** Firebase — это serverless-решение, не требующее администрирования серверов на старте. Идеально для небольшой команды.
*   **Отложенные инвестиции:** Сложная миграция на SQL откладывается на потом, давая время бизнесу вырасти и лучше понять свои потребности.

### Минусы

*   **Двойная работа:** Это главный недостаток. Мы сознательно планируем сделать **две миграции вместо одной**. Это прямые двойные затраты на разработку, тестирование и развертывание. Бизнес платит дважды за решение одной проблемы.
*   **Риск "вечного временного решения":** Существует высокий риск, что временное решение на Firestore останется навсегда, так как повторная миграция всегда будет казаться слишком сложной и дорогой в сравнении с другими задачами.
*   **Разные парадигмы:** Код, написанный для Firestore (NoSQL), практически не переиспользуется для Cloud SQL (SQL). Это потребует полной переработки всей логики доступа к данным.

---

## Вариант 2: Прямая миграция на PostgreSQL + S3

Этот подход предполагает, что мы сразу реализуем архитектуру, описанную в `docs/S3_SQL_instruction.md`.

### Плюсы

*   **Работа делается один раз:** Мы сразу строим надежный и масштабируемый фундамент, избегая двойных затрат.
*   **Мощность и гибкость запросов:** С первого дня получаем все преимущества SQL для аналитики и сложных выборок, что критически важно для e-commerce.
*   **Долгосрочная архитектурная чистота:** Мы избегаем создания запланированного технического долга.

### Минусы

*   **Более высокие начальные затраты:** Этот подход потребует немного больше времени на реализацию на старте.

---

## Вывод и Рекомендация

В текущих бизнес-реалиях **подход с поэтапной миграцией (`Firestore -> Cloud SQL`) является неоптимальным**. Он создает иллюзию безопасности, но на деле несет скрытые расходы и риски.

**Рекомендуется выбрать один из двух стратегических путей:**

1.  **Стратегический путь (наиболее предпочтительный):** Если мы уверены в долгосрочном развитии проекта и потребности в аналитике (что подтверждается наличием `S3_SQL_instruction.md`), **необходимо сразу реализовывать связку PostgreSQL + S3**. Это более зрелый и дальновидный подход.

2.  **Гибкий путь:** Если же скорость запуска является абсолютным приоритетом, а будущее туманно, то следует выбрать **Firestore + Firebase Storage в качестве основной, а не временной технологии**, и развивать продукт в рамках экосистемы Firebase, осознанно идя на ее ограничения.

**Заключение:** Следует избегать плана с двойной миграцией. Нужно принять стратегическое решение сейчас: либо инвестировать в масштабируемый SQL-фундамент, либо полностью сфокусироваться на Firebase. Учитывая имеющуюся документацию, **первый вариант выглядит наиболее обоснованным.**

---

## Обновление от 2024-08-27: Текущий статус и следующие шаги

Этот раздел фиксирует прогресс, достигнутый после выбора стратегического пути №1.

### Что реализовано на данный момент:

1.  **Архитектура:** Выбран и реализован основной стек **PostgreSQL + GCS (S3 API)**. Приложение успешно подключается к базе данных.
2.  **Доступ к данным:** Создан сервисный слой (`products.service.ts`), который отделяет логику работы с базой данных от интерфейса, следуя правилу **Data Access Layer**.
3.  **Управление товарами:** Реализован базовый CRUD-функционал. В админ-панели есть раздел `/admin/products` для просмотра и создания товаров.
4.  **Каталогизация (Этап 1):** Поле "Категория" в форме товара заменено на умный **Combobox**, который подгружает существующие категории и позволяет создавать новые "на лету".
5.  **Мониторинг:** Внедрена страница `/admin/status` для диагностики подключений к БД и хранилищу, что упрощает отладку.

### Следующий логический шаг:

Исходя из документации (`docs/categories.md`), следующим ключевым шагом является **реализация Этапа 2: Создание полноценной сущности "Категория"**.

**Что это включает:**
1.  **Изменение схемы БД:** Создание новой таблицы `categories` и замена поля `products.category` на внешний ключ `products.category_id`.
2.  **CRUD для категорий:** Создание нового раздела в админ-панели (`/admin/categories`) для централизованного управления категориями (создание, переименование, удаление).
3.  **Обновление логики:** Обновление формы создания товара и сервисного слоя для работы с новой структурой.

**Почему это важно именно сейчас:**
- **Фундамент для артикулов (SKU):** Этот шаг позволит нам хранить префиксы для артикулов и реализовать их автоматическую генерацию.
- **Стабильность и чистота данных:** Мы перейдем от хранения названий категорий в виде простого текста к надежной системе связей, что исключит ошибки и дубликаты.
- **Масштабируемость:** Заложит основу для дальнейшего расширения функционала категорий (например, добавление описаний или изображений).

---

## Обновление от 2024-08-28: Решение проблемы локальной разработки

Этот раздел фиксирует принятое архитектурное решение для обеспечения комфортной разработки в **Firebase Studio** при использовании **Cloud SQL**.

### Проблема
- База данных **Cloud SQL** по соображениям безопасности недоступна из внешнего интернета, включая среду выполнения Firebase Studio.
- Это приводило к постоянным ошибкам подключения к БД (`password authentication failed`) в окне предпросмотра, что мешало разработке и отладке UI.
- Использование **Cloud SQL Auth Proxy** (стандартное решение для локальной разработки) невозможно в рамках Firebase Studio, так как требует запуска внешней программы.

### Принятое решение: Разделение окружений
Мы приняли прагматичное решение разделить логику получения данных для разных сред:

1.  **Идентификация окружения:** Для определения среды выполнения используется проверка наличия переменной окружения `process.env.K_SERVICE`. Эта переменная автоматически устанавливается Google в облачных средах (App Hosting, Cloud Run).
    -   Если `!process.env.K_SERVICE` равно `true` — мы находимся в **локальной среде (Firebase Studio)**.
    -   Если `!process.env.K_SERVICE` равно `false` — мы находимся в **рабочей среде (Production)**.

2.  **Условная логика в сервисах:**
    -   **В локальной среде:** Функции в сервисах (`products.service.ts`, `categories.service.ts` и т.д.) не пытаются подключиться к реальной БД. Вместо этого они возвращают статические, заранее подготовленные **моковые (тестовые) данные** из файла `src/lib/mock-data.ts`.
    -   **В рабочей среде:** Функции работают в штатном режиме, выполняя запросы к реальной базе данных Cloud SQL.

### Гарантия безопасности
Этот подход гарантирует, что тестовые данные **никогда не попадут в продакшн**. Условный оператор `if (isLocal) { return mockData; }` немедленно прекращает выполнение функции, и код, отвечающий за работу с реальной БД, просто не достигается при локальном запуске. И наоборот, в рабочей среде блок с моковыми данными пропускается.

### Преимущества
- **Комфортная разработка:** Окно предпросмотра в Studio всегда работает и отображает страницы с данными, что позволяет комфортно верстать и отлаживать UI.
- **Безопасность:** Не требует компромиссов в настройках сетевой безопасности Cloud SQL.
- **Чистота данных:** Реальная база данных не захламляется тестовыми записями, созданными во время разработки.
- **Прозрачность:** Процесс разработки остается простым: разработка ведется в Studio, а управление реальным контентом — через админ-панель опубликованного приложения.
